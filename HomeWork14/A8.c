/*
        В стартер боксе Geek Brains есть электронные чашечные весы (вместимость каждой чашки 1 тонна) 
        и гири массами 1г, 3г, 9г, 27г, и т.д. по одной штуке каждой массы. 
        Менеджер из рекламного отдела взял такие весы и не знает, можно ли взвесить что-нибудь тяжелое и если можно, 
        сколько гирь придется положить на весы (на любую чашку). 
        Надо помочь ему. Формат входных данных: единственное натуральное число – масса взвешиваемого товара в граммах (не больше 1000000000). 
        Формат выходных данных: единственное целое число – общее количество гирь или число –1 если данный товар взвесить невозможно.
*/

#include <stdio.h>
#include <stdint.h>

/*
    Помимо проверок, вся работа сводится в итерации одних действий, состоящих из 2х этапов:
    1. Определяем ближайшую к весу гирю и если оставшимися сможем добрать недостающий вес, то выбираем её, иначе следующую по весу (х3)
    2. Определяем сторону, на которую ставим, если остаточный вес положительный, то на правую сторону (груз слева), иначе на левую

    --------------------------Пусть вес 20г-------------------------
    ближайшее меньшее 9: 
    сумма предыдущих: 9 + 3 + 1 = 13, меньше 20, поэтому ставим 27 (9 * 3)
    то есть + 1 гиря
    остаточный вес 20 - 27 = -7
    ближайшее меньшее 3: 3 + 1 = 4, меньше 7, поэтому ставим 9, но на другую сторону (отрицателное значение) 
    то есть + 1 гиря
    проверка того, на какую сторону ставить определяется знаком остаточного веса
    остаточный вес 20 - 27 + 9 = 2
    ближайшее меньшее 1: меньше 2, поэтому ствим 3, 
    то есть + 1 гиря
    остаточный вес 20 - 27 + 9 - 2 = 1
    если осталась 1, то считаем что можем взвесить, и добавляем гирю

    ------------------------Пусть вес 35--------------------------
    ближайшее меньшее 27: 27 + 9 + 3 + 1 = 40, больше 35, поэтому вычитаем 27
    то есть + 1 гиря
    остаточный вес 35 - 27 = 8
    ближайшее меньшее 3: 3 + 1 = 4, меньше 8, поэтому берём 9 (3 * 3)
    то есть + 1 гиря
    остаточный вес 8 - 9 = -1
    осталась единица, добавляем последнюю гирю

    ------------------------Пусть вес 2000000---------------------
    2000000 - 3 e13 = 405677 сумма больше веса (3е13 обозначает 3 в степени 13)
    3 e12 - 405677 = 125764 сумма меньше веса 
    3 e11 - 125764 = 51383 сумма меньше веса
    3 e10 - 51383 = 7666 сумма меньше веса
    7666 - 3 e8 = 1105 сумма больше веса
    3 e7 - 1105 = 1082 сумма меньше веса
    1082 - 3 e6 = 353 сумма больше веса
    353 - 3 e5 = 110 сумма больше веса
    110 - 3 е4 = 29
    29 - 3 е3 = 2
    2 - 3е 0 = 1
    1 - 3е 0 - повторение степени - отправляем -1, взвесить не можем
    
*/

int res = 0;
int weight = 0;

int iter_finder(int weight, int l_cup, int r_cup, int power);

int main(void){
    scanf("%u", &weight);
    res = iter_finder(weight, weight, 0, 10000); //пусть вес на левой чашке, 10000 в значении pow это магическое число, большее возможной степени
    printf("%d", res);
    return 0;
}

int iter_finder(int weight, int l_cup, int r_cup, int power){

    //берём абсолютное значение
    int neg_flg = 1;
    if(weight < 0){
        weight *= -1;
        neg_flg = -1;
    }

    //проверка на перевес
    if((weight > 1000000) || (l_cup > 1000000) || (r_cup > 1000000)){
        return -1;
    }

    if(weight == 0){
        return 0;
    }

    //Поиск ближайшего меньшего груза
    int closed_num = 1;
    int iters = 0;
    int cntr = 0;
    int sum = 1;

    while(closed_num * 3 < weight){
        closed_num *= 3;
        sum += closed_num;
        iters++;
    }

    //определение груза
    if(sum < weight){ //это значит, что оставшимися грузами мы вес не зададим, надо ставить следующий по весу груз
        cntr++;
        int next_iter = 0;
        //определяем, на какую чашу ставить
        if(weight * neg_flg > 0){   //если вес положительный, то ставим на правую чашу
            next_iter = iter_finder((weight - 3 * closed_num), l_cup, r_cup + 3 * closed_num,  iters + 1);
        }
        else{   //иначе кидаем на левую чашу
            next_iter = iter_finder((3 * closed_num - weight), l_cup + 3 * closed_num, r_cup,  iters + 1);
        }
        //Проверка на повторный груз и успешные предыдущие итерации
        if((iters + 1 >= power) || (next_iter < 0)){
            return -1;
        }
        return cntr + next_iter;        
    }

    else if(sum > weight){  //это значит, что оставшихся грузов хватит как минимум чтобы перевесить чашу
        cntr++;
        int next_iter = 0;
        //определяем, на какую чашу ставить
        if(weight * neg_flg > 0){   //если вес положительный, то ставим на правую чашу
            next_iter =  iter_finder((weight - closed_num), l_cup, r_cup + closed_num, iters);
        }
        else{    //иначе кидаем на левую чашу
            next_iter =  iter_finder((closed_num - weight), l_cup, r_cup + closed_num, iters);
        }

        //Проверка на повторный груз и успешные предыдущие итерации
        if((iters >= power) || (next_iter < 0)){
            return -1;
        }
        return cntr + next_iter;       
    }

    else{   //сумма всех грузов точно уравнивает чаши
        return iters + 1;
    }
}

